<?xml version="1.0"?>
<ModuleObject xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" fVersion="1.1" type="Script" mclass="Module" useSupports="false">
  <Name>DebugPx</Name>
  <Version>1.0.0.0</Version>
  <Description>The DebugPx module provides a set of commands that make it easier to debug PowerShell scripts, functions and modules. These commands leverage the native debugging capabilities in PowerShell (the callstack, breakpoints, error output and the -Debug common parameter) and provide additional functionality that these features do not provide, enabling a richer debugging experience.</Description>
  <HasManifest>false</HasManifest>
  <OverridePostCount>false</OverridePostCount>
  <FetchPostCount xsi:nil="true" />
  <Cmdlets>
    <CmdletObject verb="Disable" noun="BreakpointCommand">
      <Name>Disable-BreakpointCommand</Name>
      <GeneralHelp>
        <Synopsis />
        <Description />
        <Notes />
        <InputType />
        <InputUrl />
        <InputTypeDescription />
        <ReturnType />
        <ReturnUrl />
        <ReturnTypeDescription />
      </GeneralHelp>
      <ParamSets>
        <CommandParameterSetInfo2 Name="__AllParameterSets" Params="Verbose Debug ErrorAction WarningAction ErrorVariable WarningVariable OutVariable OutBuffer PipelineVariable WhatIf Confirm" />
      </ParamSets>
      <Syntax>
        <string>Disable-BreakpointCommand [-WhatIf] [-Confirm]</string>
      </Syntax>
      <Parameters>
        <ParameterDescription type="SwitchParameter" varLen="false" required="false" dynamic="false" pipeRemaining="false" pipe="false" pipeProp="false" isPos="false" pos="named" globbing="false">
          <Name>WhatIf</Name>
          <Attributes>
            <string>System.Management.Automation.ParameterAttribute</string>
            <string>System.Management.Automation.AliasAttribute</string>
          </Attributes>
          <Aliases>
            <string>wi</string>
          </Aliases>
          <Description />
          <DefaultValue />
        </ParameterDescription>
        <ParameterDescription type="SwitchParameter" varLen="false" required="false" dynamic="false" pipeRemaining="false" pipe="false" pipeProp="false" isPos="false" pos="named" globbing="false">
          <Name>Confirm</Name>
          <Attributes>
            <string>System.Management.Automation.AliasAttribute</string>
            <string>System.Management.Automation.ParameterAttribute</string>
          </Attributes>
          <Aliases>
            <string>cf</string>
          </Aliases>
          <Description />
          <DefaultValue />
        </ParameterDescription>
      </Parameters>
      <Examples />
      <RelatedLinks />
      <SupportInformation ad="false" rsat="false" ps2="false" ps3="false" ps4="false" ps5="false" wxp="false" wv="false" w7="false" w8="false" w81="false" w2k3s="false" w2k3e="false" w2k3d="false" w2k8s="false" w2k8e="false" w2k8d="false" w2k8r2s="false" w2k8r2e="false" w2k8r2d="false" w2k12s="false" w2k12d="false" w2k12r2s="false" w2k12r2d="false" />
      <Publish>false</Publish>
    </CmdletObject>
    <CmdletObject verb="Enable" noun="BreakpointCommand">
      <Name>Enable-BreakpointCommand</Name>
      <GeneralHelp>
        <Synopsis />
        <Description />
        <Notes />
        <InputType />
        <InputUrl />
        <InputTypeDescription />
        <ReturnType />
        <ReturnUrl />
        <ReturnTypeDescription />
      </GeneralHelp>
      <ParamSets>
        <CommandParameterSetInfo2 Name="__AllParameterSets" Params="Verbose Debug ErrorAction WarningAction ErrorVariable WarningVariable OutVariable OutBuffer PipelineVariable WhatIf Confirm" />
      </ParamSets>
      <Syntax>
        <string>Enable-BreakpointCommand [-WhatIf] [-Confirm]</string>
      </Syntax>
      <Parameters>
        <ParameterDescription type="SwitchParameter" varLen="false" required="false" dynamic="false" pipeRemaining="false" pipe="false" pipeProp="false" isPos="false" pos="named" globbing="false">
          <Name>WhatIf</Name>
          <Attributes>
            <string>System.Management.Automation.ParameterAttribute</string>
            <string>System.Management.Automation.AliasAttribute</string>
          </Attributes>
          <Aliases>
            <string>wi</string>
          </Aliases>
          <Description />
          <DefaultValue />
        </ParameterDescription>
        <ParameterDescription type="SwitchParameter" varLen="false" required="false" dynamic="false" pipeRemaining="false" pipe="false" pipeProp="false" isPos="false" pos="named" globbing="false">
          <Name>Confirm</Name>
          <Attributes>
            <string>System.Management.Automation.AliasAttribute</string>
            <string>System.Management.Automation.ParameterAttribute</string>
          </Attributes>
          <Aliases>
            <string>cf</string>
          </Aliases>
          <Description />
          <DefaultValue />
        </ParameterDescription>
      </Parameters>
      <Examples />
      <RelatedLinks />
      <SupportInformation ad="false" rsat="false" ps2="false" ps3="false" ps4="false" ps5="false" wxp="false" wv="false" w7="false" w8="false" w81="false" w2k3s="false" w2k3e="false" w2k3d="false" w2k8s="false" w2k8e="false" w2k8d="false" w2k8r2s="false" w2k8r2e="false" w2k8r2d="false" w2k12s="false" w2k12d="false" w2k12r2s="false" w2k12r2d="false" />
      <Publish>false</Publish>
    </CmdletObject>
    <CmdletObject verb="Invoke" noun="IfDebug">
      <Name>Invoke-IfDebug</Name>
      <GeneralHelp>
        <Synopsis>Invokes a series of commands when in debug mode and sends any output those commands generate to the debug stream.</Synopsis>
        <Description>The ifdebug command invokes a series of commands when in debug mode and sends any output that those commands generate to the debug stream.

You can use the ifdebug command in a pipeline to output debug information related to objects as they are passed through the pipeline. When debug mode is disabled, the objects will simply be passed through without the debug commands being invoked.

In order to enable debug mode in PowerShell, you either need to invoke the command you want to debug with the -Debug common parameter, or you need to set $DebugPreference to any value other than Ignore or SilentlyContinue.

The ifdebug command allows command authors to include blocks of script that output debug information to the debug stream without concern that leaving those blocks of script in place will impact performance or generate confusing output when the command is used normally. This is very useful for support purposes, allowing command authors to gather very specific pieces of information during the invocation of a PowerShell command by simply instructing an end user to run the command with the -Debug switch.</Description>
        <Notes>The -Debug common parameter has been in PowerShell since version 1. It was originally designed to allow script authors to conditionally enter a nested prompt at a specific location when running a script. Using -Debug when invoking a command would result in the caller being prompted whenever a Write-Debug command was invoked. This would happen because $DebugPreference would be set to "Inquire" whenever -Debug was used.

While this design worked for PowerShell 1.0, it is fundamentally flawed in PowerShell 2.0 and later where breakpoint support is available. Breakpoints allow script authors to control when they want a script to stop execution, and stopping execution is a script author activity, not a script consumer activity. All use of Write-Debug inside of commands would either have to be commented out or removed entirely before a command was shipped, unless the command author wanted end users to deal with debug mode when they invoked a command with -Debug.

A better use case for -Debug would be to provide additional output that is useful when troubleshooting issues with a command, including object data that would normally not be output and that would make even a Verbose stream look busy. Unlike Verbose output, which is usually descriptive, Debug output is more often not, and it is only helpful to a command author when troubleshooting issues. The ifdebug command solves this need by providing a script block that will only be invoked if the command is either invoked with -Debug or if the $DebugPreference variable in a scope where the command is invoked is set to any value other than SilentlyContinue or Ignore. In these scenarios, $DebugPreference is set to Continue before the DebugScript is invoked, all output generated by the DebugScript is written to the Debug stream, and then $DebugPreference is set back to its original value once the DebugScript has completed. With this model, there is no need to remove an ifdebug command invocation from a script when it comes time to release it to customers.</Notes>
        <InputType>System.Management.Automation.PSObject</InputType>
        <InputUrl />
        <InputTypeDescription />
        <ReturnType>System.Management.Automation.PSObject</ReturnType>
        <ReturnUrl />
        <ReturnTypeDescription />
      </GeneralHelp>
      <ParamSets>
        <CommandParameterSetInfo2 Name="__AllParameterSets" Params="DebugScript InputObject Verbose Debug ErrorAction WarningAction ErrorVariable WarningVariable OutVariable OutBuffer PipelineVariable" />
      </ParamSets>
      <Syntax>
        <string>Invoke-IfDebug [-DebugScript] &lt;ScriptBlock&gt; [-InputObject &lt;PSObject&gt;]</string>
      </Syntax>
      <Parameters>
        <ParameterDescription type="ScriptBlock" varLen="false" required="true" dynamic="false" pipeRemaining="false" pipe="false" pipeProp="false" isPos="true" pos="0" globbing="false">
          <Name>DebugScript</Name>
          <Attributes>
            <string>System.Management.Automation.AliasAttribute</string>
            <string>System.Management.Automation.ValidateNotNullAttribute</string>
            <string>System.Management.Automation.ParameterAttribute</string>
          </Attributes>
          <Aliases>
            <string>ScriptBlock</string>
            <string>sb</string>
          </Aliases>
          <Description>The script block that will be invoked when debug mode is enabled.

When the ifdebug command is used in a pipeline, you can use the $_ or $PSItem variables to reference the current item that was just received from the previous stage in the pipeline.</Description>
          <DefaultValue />
        </ParameterDescription>
        <ParameterDescription type="PSObject" varLen="false" required="false" dynamic="false" pipeRemaining="false" pipe="true" pipeProp="false" isPos="false" pos="named" globbing="false">
          <Name>InputObject</Name>
          <Attributes>
            <string>System.Management.Automation.ParameterAttribute</string>
            <string>System.Management.Automation.ValidateNotNullAttribute</string>
          </Attributes>
          <Aliases />
          <Description>The object that was input to the command, either by value (using this parameter) or through the pipeline.

When ifdebug is invoked while debug mode is disabled, input objects will be passed directly through to the next stage in the pipeline without any additional processing.</Description>
          <DefaultValue />
        </ParameterDescription>
      </Parameters>
      <Examples>
        <Example>
          <Name>EXAMPLE 1</Name>
          <Cmd>PS C:\&gt; function Test-Debug {
&gt;&gt;     [CmdletBinding()]
&gt;&gt;     param()
&gt;&gt;     ifdebug {
&gt;&gt;         Write-Debug 'Anything you output here is sent to the debug stream.'
&gt;&gt;         'Even ordinary strings and objects.'
&gt;&gt;         Get-Service wuauserv
&gt;&gt;     }
&gt;&gt; }
PS C:\&gt; Test-Debug
PS C:\&gt; Test-Debug -Debug</Cmd>
          <Description>The first command in this example creates a function that includes some debug output. Then once that function is created, the second command invokes the function without using the -Debug parameter. No output is generated. Finally, the last command invokes the function with the -Debug parameter, and all of the output from the ifdebug block is written to the debug stream and displayed in the console.</Description>
        </Example>
      </Examples>
      <RelatedLinks />
      <SupportInformation ad="false" rsat="false" ps2="false" ps3="false" ps4="false" ps5="false" wxp="false" wv="false" w7="false" w8="false" w81="false" w2k3s="false" w2k3e="false" w2k3d="false" w2k8s="false" w2k8e="false" w2k8d="false" w2k8r2s="false" w2k8r2e="false" w2k8r2d="false" w2k12s="false" w2k12d="false" w2k12r2s="false" w2k12r2d="false" />
      <Publish>false</Publish>
    </CmdletObject>
    <CmdletObject verb="Enter" noun="Debugger">
      <Name>Enter-Debugger</Name>
      <GeneralHelp>
        <Synopsis>Enters the debugger by triggering a breakpoint at the current location.</Synopsis>
        <Description>The breakpoint command enters the debugger by triggering a breakpoint at the current location, whether that location be in a script file or in an interactive prompt.

Without the ConditionScript parameter, the breakpoint command will enter the debugger by triggering a breakpoint where it is invoked. You can also use the breakpoint command to conditionally enter the debugger by providing an expression in the ConditionScript parameter. If the ConditionScript parameter evaluates to True, then the execution will be suspended at a breakpoint. If the ConditionScript parameter evaluates to False, then execution will continue beyond the breakpoint command.

You can use the breakpoint command in a pipeline. If the breakpoint command is used in a pipeline, it will break for each object that it receives from the previous stage in the pipeline, conditionally if the ConditionScript parameter is used. If the breakpoint command is disabled, the object will be passed down the pipeline to the next stage, allowing breakpoint commands to be left in place while you disable or enable them as required when developing your PowerShell solutions.

When you are setting breakpoints with more complex conditions or for more rare scenarios such as intermittent issues that you can't put your finger on, it can be helpful to know more context about those breakpoints when they are hit. For these situations, you can specify a message that you want written directly to the host using the Message parameter. The message you provide will be output to the host just before PowerShell enters the debugger, but only if the breakpoint condition passes.

You can enable or disable the breakpoint command at any time by invoking either the Enable-BreakpointCommand or Disable-BreakpointCommand commands.

The breakpoint command will not cause PowerShell to enter the debugger unless the current process is interactive.</Description>
        <Notes>It is recommended that the breakpoint alias be used in place of Enter-Debugger because it more clearly indicates the intent of the command. This is an exception to the normal rule recommendation to use command names in place of aliases in scripts; however, all breakpoint command invocations should be removed from scripts before they are officially released, so that shouldn't be an issue.</Notes>
        <InputType>System.Management.Automation.PSObject</InputType>
        <InputUrl />
        <InputTypeDescription />
        <ReturnType>System.Management.Automation.PSObject</ReturnType>
        <ReturnUrl />
        <ReturnTypeDescription />
      </GeneralHelp>
      <ParamSets>
        <CommandParameterSetInfo2 Name="__AllParameterSets" Params="ConditionScript Message InputObject Verbose Debug ErrorAction WarningAction ErrorVariable WarningVariable OutVariable OutBuffer PipelineVariable" />
      </ParamSets>
      <Syntax>
        <string>Enter-Debugger [[-ConditionScript] &lt;ScriptBlock&gt;] [-Message &lt;String&gt;] [-InputObject &lt;PSObject&gt;]</string>
      </Syntax>
      <Parameters>
        <ParameterDescription type="ScriptBlock" varLen="false" required="false" dynamic="false" pipeRemaining="false" pipe="false" pipeProp="false" isPos="true" pos="0" globbing="false">
          <Name>ConditionScript</Name>
          <Attributes>
            <string>System.Management.Automation.AliasAttribute</string>
            <string>System.Management.Automation.ParameterAttribute</string>
            <string>System.Management.Automation.ValidateNotNullAttribute</string>
          </Attributes>
          <Aliases>
            <string>ScriptBlock</string>
            <string>sb</string>
          </Aliases>
          <Description>The condition under which PowerShell will enter the debugger at a breakpoint at the current location.

When the breakpoint command is used in a pipeline, you can use the $_ or $PSItem variables to reference the current item that was just received from the previous stage in the pipeline.</Description>
          <DefaultValue>{$true}</DefaultValue>
        </ParameterDescription>
        <ParameterDescription type="PSObject" varLen="false" required="false" dynamic="false" pipeRemaining="false" pipe="true" pipeProp="false" isPos="false" pos="named" globbing="false">
          <Name>InputObject</Name>
          <Attributes>
            <string>System.Management.Automation.ParameterAttribute</string>
            <string>System.Management.Automation.ValidateNotNullAttribute</string>
          </Attributes>
          <Aliases />
          <Description>The object that was input to the command, either by value (using this parameter) or through the pipeline.

If the breakpoint command is disabled when it is invoked in a pipeline, input objects will be passed directly through to the next stage in the pipeline without any additional processing.</Description>
          <DefaultValue />
        </ParameterDescription>
        <ParameterDescription type="String" varLen="false" required="false" dynamic="false" pipeRemaining="false" pipe="false" pipeProp="false" isPos="false" pos="named" globbing="false">
          <Name>Message</Name>
          <Attributes>
            <string>System.Management.Automation.ValidateNotNullOrEmptyAttribute</string>
            <string>System.Management.Automation.ParameterAttribute</string>
          </Attributes>
          <Aliases />
          <Description>A message that you want output to the host when the breakpoint is triggered.</Description>
          <DefaultValue />
        </ParameterDescription>
      </Parameters>
      <Examples>
        <Example>
          <Name>EXAMPLE 1</Name>
          <Cmd>PS C:\&gt; Get-Service w* | breakpoint {$_.Name -eq 'wuauserv'} | Select-Object -ExpandProperty Name</Cmd>
          <Description>If the breakpoint command is enabled (it is enabled by default), this command will get a list of names of services whose name starts with "w". When the Windows Update service is received by the breakpoint command, Windows PowerShell will enter the debugger at that breakpoint. The name of that service, and any remaining services, will be output to the console when the debugger is used to either step or to resume execution.</Description>
        </Example>
        <Example>
          <Name>EXAMPLE 2</Name>
          <Cmd>PS C:\&gt; &amp; {
&gt;&gt;     'Before breakpoint'
&gt;&gt;     breakpoint
&gt;&gt;     'After breakpoint'
&gt;&gt; }</Cmd>
          <Description>This command will output the text "Before breakpoint" to the console. Then, when the breakpoint command is invoked, if the breakpoint command is enabled (the default), Windows PowerShell will enter the debugger at the breakpoint command. The text "After breakpoint" will be output to the console when the debugger is used to step or to continue execution of the command.</Description>
        </Example>
        <Example>
          <Name>EXAMPLE 3</Name>
          <Cmd>PS C:\&gt; breakpoint {
&gt;&gt;     $service = Get-Service wuauserv
&gt;&gt;     $service.Status -eq 'Stopped'
&gt;&gt; } -Message "The Windows Update service has stopped! How did this happen?"</Cmd>
          <Description>This command causes PowerShell to enter the debugger at a breakpoint on that command, but only if the Windows Update service is in a stopped state. When PowerShell enters the debugger, the message "The Windows Update service has stopped! How did this happen?" will be written directly to the host. These messages may help understand what condition you are watching for on conditional breakpoints in more complex scripting scenarios.</Description>
        </Example>
      </Examples>
      <RelatedLinks>
        <RelatedLink>
          <LinkText>Disable-BreakpointCommand</LinkText>
          <LinkUrl />
        </RelatedLink>
        <RelatedLink>
          <LinkText>Enable-BreakpointCommand</LinkText>
          <LinkUrl />
        </RelatedLink>
      </RelatedLinks>
      <SupportInformation ad="false" rsat="false" ps2="false" ps3="false" ps4="false" ps5="false" wxp="false" wv="false" w7="false" w8="false" w81="false" w2k3s="false" w2k3e="false" w2k3d="false" w2k8s="false" w2k8e="false" w2k8d="false" w2k8r2s="false" w2k8r2e="false" w2k8r2d="false" w2k12s="false" w2k12d="false" w2k12r2s="false" w2k12r2d="false" />
      <Publish>false</Publish>
    </CmdletObject>
  </Cmdlets>
</ModuleObject>